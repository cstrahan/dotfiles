#!/bin/sh

# replace all newlines with escape code.
smush() {
  while read line; do printf "%s" "$line\\n"; done
}

# escape backslashes and double quotes.
escape() {
  sed 's@\("\|\\\)@\\\1@g'
}

if ghc-pkg describe pretty-show >/dev/null 2>&1; then
  havePrettyShow=1
fi

if ghc-pkg describe hscolour >/dev/null 2>&1; then
  haveHsColour=1
fi

# TODO: I forget if I need these...
# :set -package pretty-show
# :set -package hscolour

if [[ -n "$havePrettyShow" ]]; then
  cat <<"EOF"
import qualified Text.Show.Pretty
:def ppr \x -> return $ "putStrLn $ Text.Show.Pretty.ppShow $ " ++ x
let interactivePrint = putStrLn . Text.Show.Pretty.ppShow
:set -interactive-print=interactivePrint
EOF
fi

if [[ -n "$haveHsColour" ]]; then
  cat <<"EOF"
import qualified Language.Haskell.HsColour           as HsColour
import qualified Language.Haskell.HsColour.Colourise as HsColour
import qualified Language.Haskell.HsColour.Output    as HsColour

:{
let colourPrefs = HsColour.defaultColourPrefs {
  HsColour.conid    = [ HsColour.Foreground HsColour.Yellow, HsColour.Bold ],
  HsColour.conop    = [ HsColour.Foreground HsColour.Yellow ],
  HsColour.string   = [ HsColour.Foreground HsColour.Green ],
  HsColour.char     = [ HsColour.Foreground HsColour.Cyan ],
  HsColour.number   = [ HsColour.Foreground HsColour.Red, HsColour.Bold ],
  HsColour.layout   = [ HsColour.Foreground HsColour.White ],
  HsColour.keyglyph = [ HsColour.Foreground HsColour.White ]
}
:}
EOF
fi

if [[ -n "$haveHsColour" ]] && [[ -n "$havePrettyShow" ]]; then
  cat <<"EOF"
let interactivePrintColor = putStrLn . HsColour.hscolour (HsColour.TTYg HsColour.XTerm256Compatible) colourPrefs False False "" False . Text.Show.Pretty.ppShow
let interactivePrint = interactivePrintColor
:def pprc \x -> return $ "interactivePrintColor $ " ++ x
EOF
fi
